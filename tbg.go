package main

import (
	"fmt"
	"math/rand/v2"
	"net/http"
	"strconv"
	"time"

	"github.com/eiannone/keyboard"
)

type TbgState struct {
	// Slice of images under a path to randomly choose the next image from.
	//
	// Dynamically generated by ImagesPath.images() in TbgState.updateCurrentPathState()
	Images []string
	// slice of paths defined in the tbg config (.tbg.yml)
	Paths []ImagesPath
	// tbg config where paths, interval, and profile information is from
	Config *Config
	// Used for logging the config with the current execution state
	ConfigPath string
	// Alignment of the current path chosen in TbgState.updateCurrentPathState()
	CurrentAlignment string
	// Opacity of the current path chosen in TbgState.updateCurrentPathState()
	CurrentOpacity float32
	// Stretch of the current path chosen in TbgState.updateCurrentPathState()
	CurrentStretch string
	// Events for TbgState goroutines to communicate with each other
	Events *TbgEvents
	// Used to call the WTSettings.Write() method to update WT's settings.json
	// with the current background image
	Settings *WTSettings
}

func (tbg *TbgState) String() string {
	return fmt.Sprint(`TbgState
  ConfigPath: `, tbg.ConfigPath, `
  Config: `, tbg.Config, `
  CurrentPathAlignment: `, tbg.CurrentAlignment, `
  CurrentPathStretch: `, tbg.CurrentStretch, `
  CurrentPathOpacity: `, tbg.CurrentOpacity, `
  Images: `, tbg.Images[0], `...`, tbg.Images[len(tbg.Images)-1],
	)
}

// Events for TbgState goroutines to communicate with each other
type TbgEvents struct {
	Done      chan struct{}
	NextImage chan struct{}
	// all TbgState errors must be routed here. The only method that's allowed
	// to return an error is TbgState.eventHandler() which handles the errors
	// as well
	Error chan error
}

func NewTbgState(config *Config, configPath string, alignment string, stretch string, opacity float32) (*TbgState, error) {
	wtSettings, err := NewWTSettings()
	if err != nil {
		return nil, err
	}
	return &TbgState{
		Images:           make([]string, 2),
		Paths:            config.Paths,
		Config:           config,
		ConfigPath:       configPath,
		CurrentAlignment: alignment,
		CurrentStretch:   stretch,
		CurrentOpacity:   opacity,
		Events: &TbgEvents{
			Done:      make(chan struct{}),
			NextImage: make(chan struct{}),
			Error:     make(chan error),
		},
		Settings: wtSettings,
	}, nil
}

func (tbg *TbgState) Start() error {
	if len(tbg.Config.Paths) == 0 {
		return fmt.Errorf(`config at "%s" has no paths`, tbg.ConfigPath)
	}
	if err := tbg.updateCurrentPathState(); err != nil {
		return fmt.Errorf("Failed to initialize tbg: %s", err.Error())
	}
	go tbg.readUserInput()
	go tbg.imageUpdateTicker()
	go tbg.startServer()
	return tbg.eventHandler()
}

// Based on the current path index, update the expected alignment, opacity,
// and stretch of the image
func (tbg *TbgState) updateCurrentPathState() error {
	randomPath := tbg.Config.Paths[uint16(rand.IntN(len(tbg.Config.Paths)))]
	tbg.CurrentAlignment = Option(randomPath.Alignment).UnwrapOr(DefaultAlignment)
	tbg.CurrentStretch = Option(randomPath.Stretch).UnwrapOr(DefaultStretch)
	tbg.CurrentOpacity = Option(randomPath.Opacity).UnwrapOr(DefaultOpacity)
	var err error
	tbg.Images, err = randomPath.Images()
	return err
}

// Changes the background image. The image is randomly chosen from images in
// dirs under "paths" in the tbg config file (.tbg.yml)
func (tbg *TbgState) changeImage() error {
	currentImage, err := tbg.nextImage()
	if err != nil {
		return err
	}
	err = tbg.Settings.Write(currentImage,
		tbg.Config.Profile,
		tbg.CurrentAlignment,
		tbg.CurrentStretch,
		tbg.CurrentOpacity,
	)
	if err != nil {
		return err
	}
	tbg.Config.Log(tbg.ConfigPath).RunSettings(
		currentImage,
		tbg.Config.Profile,
		tbg.Config.Interval,
		tbg.CurrentAlignment,
		tbg.CurrentStretch,
		tbg.CurrentOpacity,
	)
	return nil
}

// Selects a random image from dirs in "paths" field set in tbg config
// (.tbg.yml)
func (tbg *TbgState) nextImage() (string, error) {
	err := tbg.updateCurrentPathState()
	if err != nil {
		return "", err
	}
	return tbg.Images[uint16(rand.IntN(len(tbg.Images)))], nil
}

// Listens to user keyboard input and emits TbgState events based on that.
func (tbg *TbgState) readUserInput() {
	keysEvents, err := keyboard.GetKeys(10)
	if err != nil {
		tbg.Events.Error <- err
	}
	defer func() {
		_ = keyboard.Close()
	}()
	for {
		event := <-keysEvents
		if event.Err != nil {
			tbg.Events.Error <- event.Err
		}
		switch keyboard.Key(event.Rune) {
		case keyboard.Key('c'):
			commandList()
		case keyboard.Key('n'):
			tbg.Events.NextImage <- struct{}{}
		case keyboard.Key('q'):
			fmt.Println("Exiting...")
			close(tbg.Events.Done)
			return
		case keyboard.Key('d'): // debug
			fmt.Println(tbg)
		default:
			fmt.Printf("invalid key '%c' ('c' for list of [c]ommand)\n", event.Rune)
		}
	}
}

// Creates a ticker that emits a NextImage Event every *interval* minutes where
// interval is defined in the tbg config (.tbg.yml)
func (tbg *TbgState) imageUpdateTicker() {
	ticker := time.Tick(time.Duration(tbg.Config.Interval) * time.Minute)
	for {
		select {
		case <-ticker:
			tbg.Events.NextImage <- struct{}{}
		}
	}
}

// may emit TbgState.Events.Error (e.g. port is taken)
func (tbg *TbgState) startServer() {
	http.HandleFunc("POST /next-image", func(w http.ResponseWriter, _ *http.Request) {
		tbg.Events.NextImage <- struct{}{}
		fmt.Fprint(w, "next-image: changed image successfully")
	})
	http.HandleFunc("POST /quit", func(w http.ResponseWriter, _ *http.Request) {
		fmt.Fprint(w, "quit: stopped server successfully. Goodbye!")
		close(tbg.Events.Done)
	})
	tbgPort := ":" + strconv.FormatUint(uint64(tbg.Config.Port), 10)
	err := http.ListenAndServe(tbgPort, nil)
	if err != nil {
		tbg.Events.Error <- err
	}
}

// Handles events emitted by various TbgState methods.
func (tbg *TbgState) eventHandler() error {
	for {
		select {
		case <-tbg.Events.Done:
			fmt.Println("Goodbye!")
			return nil
		case err := <-tbg.Events.Error:
			return err
		case <-tbg.Events.NextImage:
			if err := tbg.changeImage(); err != nil {
				return err
			}
		}
	}
}

func commandList() {
	fmt.Print(`
q: [q]uit
n: [n]ext image
c: [c]ommand list
`)
}
