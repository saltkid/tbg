package main

import (
	"encoding/json"
	"fmt"
	"io"
	"log/slog"
	"math/rand/v2"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"gopkg.in/natefinch/lumberjack.v2"
)

type TbgState struct {
	// Slice of images under a path to randomly choose the next image from.
	//
	// Dynamically generated by ImagesPath.images() in TbgState.updateCurrentPathState()
	Images []string
	// slice of paths defined in the tbg config
	Paths []ImagesPath
	// tbg config where paths, interval, and profile information is from
	Config *Config
	// Used for logging the config with the current execution state
	ConfigPath string
	// passed through --alignment flag. will override all alignment values,
	// regardless of what is in the config
	OverrideAlignment *string
	// passed through --opacity flag. will override all opacity values,
	// regardless of what is in the config
	OverrideOpacity *float32
	// passed through --stretch flag. will override all stretch values,
	// regardless of what is in the config
	OverrideStretch *string
	// Events for TbgState goroutines to communicate with each other
	Events *TbgEvents
	// Used to call the WTSettings.Write() method to update WT's settings.json
	// with the current background image
	Settings *WTSettings
}

func (tbg *TbgState) String() string {
	return fmt.Sprint(`TbgState
  ConfigPath: `, tbg.ConfigPath, `
  Config: `, tbg.Config, `
  Images: `, tbg.Images[0], `...`, tbg.Images[len(tbg.Images)-1],
	)
}

// Events for TbgState goroutines to communicate with each other
type TbgEvents struct {
	Done      chan struct{}
	NextImage chan NextImageEvent
	SetImage  chan SetImageEvent
	// all TbgState errors must be routed here. The only method that's allowed
	// to return an error is TbgState.eventHandler() which handles the errors
	// as well
	Error chan error
}

type NextImageEvent struct {
	Alignment *string
	Opacity   *float32
	Stretch   *string
}

type SetImageEvent struct {
	Path      string
	Alignment *string
	Opacity   *float32
	Stretch   *string
}

func NewTbgState(config *Config, configPath string, alignment *string, opacity *float32, stretch *string) (*TbgState, error) {
	wtSettings, err := NewWTSettings()
	if err != nil {
		return nil, err
	}
	return &TbgState{
		Images:            make([]string, 2),
		Paths:             config.Paths,
		Config:            config,
		ConfigPath:        configPath,
		OverrideAlignment: alignment,
		OverrideOpacity:   opacity,
		OverrideStretch:   stretch,
		Events: &TbgEvents{
			Done:      make(chan struct{}),
			NextImage: make(chan NextImageEvent),
			SetImage:  make(chan SetImageEvent),
			Error:     make(chan error),
		},
		Settings: wtSettings,
	}, nil
}

func (tbg *TbgState) Start() error {
	if len(tbg.Config.Paths) == 0 {
		return fmt.Errorf(`config at "%s" has no paths`, shrinkHome(tbg.ConfigPath))
	}
	logFile := &lumberjack.Logger{
		Filename:   filepath.Join(filepath.Dir(tbg.ConfigPath), "tbg.log"),
		MaxSize:    5,
		MaxAge:     7,
		MaxBackups: 2,
		LocalTime:  true,
		Compress:   true,
	}
	multiHandler := slog.NewJSONHandler(io.MultiWriter(logFile, os.Stdout), nil)
	slog.SetDefault(slog.New(multiHandler))
	slog.Info("Start tbg...Config used",
		"paths", func() []map[string]any {
			ret := make([]map[string]any, len(tbg.Config.Paths))
			for i, path := range tbg.Config.Paths {
				entry := make(map[string]any, 0)
				entry["path"] = path.Path
				if path.Alignment != nil {
					entry["alignment"] = path.Alignment
				}
				if path.Opacity != nil {
					entry["opacity"] = path.Opacity
				}
				if path.Stretch != nil {
					entry["stretch"] = path.Stretch
				}
				ret[i] = entry
			}
			return ret
		}(),
		"interval", tbg.Config.IntervalOrDefault(),
		"port", tbg.Config.PortOrDefault(),
		"profile", tbg.Config.ProfileOrDefault(),
	)
	go tbg.imageUpdateTicker()
	go tbg.startServer()
	return tbg.eventHandler()
}

// Creates a ticker that emits a NextImage Event every *interval* minutes where
// interval is defined in the tbg config
func (tbg *TbgState) imageUpdateTicker() {
	ticker := time.Tick(time.Duration(tbg.Config.IntervalOrDefault()) * time.Minute)
	for {
		select {
		case <-ticker:
			slog.Info("Image change tick")
			tbg.Events.NextImage <- NextImageEvent{
				Alignment: nil,
				Opacity:   nil,
				Stretch:   nil,
			}
		}
	}
}

// may emit TbgState.Events.Error (e.g. port is taken)
func (tbg *TbgState) startServer() {
	http.HandleFunc("POST /next-image", func(w http.ResponseWriter, r *http.Request) {
		slog.Info("Recieved next-image request")
		var reqBody NextImageRequestBody
		if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
			tbg.Events.Error <- fmt.Errorf("Failed to decode request body: %s", err)
			return
		}
		slog.Info("next-image body decoded")
		if reqBody.Alignment != nil {
			slog.Info("alignment", "value", *reqBody.Alignment)
		}
		if reqBody.Opacity != nil {
			slog.Info("opacity", "value", *reqBody.Opacity)
		}
		if reqBody.Stretch != nil {
			slog.Info("stretch", "value", *reqBody.Stretch)
		}
		tbg.Events.NextImage <- NextImageEvent{
			Alignment: reqBody.Alignment,
			Opacity:   reqBody.Opacity,
			Stretch:   reqBody.Stretch,
		}
		fmt.Fprint(w, "next-image: changed image successfully")
	})

	http.HandleFunc("POST /set-image", func(w http.ResponseWriter, r *http.Request) {
		slog.Info("Recieved set-image request")
		var reqBody SetImageRequestBody
		if err := json.NewDecoder(r.Body).Decode(&reqBody); err != nil {
			tbg.Events.Error <- fmt.Errorf("Failed to decode request body: %s", err)
			return
		}
		slog.Info("set-image body decoded")
		slog.Info("Path", "value", reqBody.Path)
		if reqBody.Alignment != nil {
			slog.Info("Alignment", "value", *reqBody.Alignment)
		}
		if reqBody.Opacity != nil {
			slog.Info("Opacity", "value", *reqBody.Opacity)
		}
		if reqBody.Stretch != nil {
			slog.Info("Stretch", "value", *reqBody.Stretch)
		}
		tbg.Events.SetImage <- SetImageEvent{
			Path:      reqBody.Path,
			Alignment: reqBody.Alignment,
			Opacity:   reqBody.Opacity,
			Stretch:   reqBody.Stretch,
		}
		fmt.Fprint(w, "set-image: changed image successfully")
	})

	http.HandleFunc("POST /quit", func(w http.ResponseWriter, _ *http.Request) {
		slog.Info("Recieved quit request")
		fmt.Fprint(w, "quit: stopped server successfully. Goodbye!")
		close(tbg.Events.Done)
	})

	tbgPort := ":" + strconv.FormatUint(uint64(tbg.Config.PortOrDefault()), 10)
	slog.Info("Starting server...",
		"interval", tbg.Config.IntervalOrDefault(),
		"port", tbgPort,
		"profile", tbg.Config.ProfileOrDefault(),
		"override-alignment", Option(tbg.OverrideAlignment).UnwrapOr("no override"),
		"override-opacity", func() string {
			if tbg.OverrideOpacity != nil {
				return strconv.FormatFloat(float64(*tbg.OverrideOpacity), 'f', -1, 32)
			}
			return "no override"
		}(),
		"override-stretch", Option(tbg.OverrideStretch).UnwrapOr("no override"),
	)
	err := http.ListenAndServe(tbgPort, nil)
	if err != nil {
		tbg.Events.Error <- err
	}
}

// Handles events emitted by various TbgState methods.
func (tbg *TbgState) eventHandler() error {
	for {
		select {
		case <-tbg.Events.Done:
			slog.Info("Goodbye!")
			return nil
		case err := <-tbg.Events.Error:
			return err
		case evt := <-tbg.Events.NextImage:
			if err := tbg.changeToRandomImage(evt.Alignment, evt.Opacity, evt.Stretch); err != nil {
				return err
			}
		case evt := <-tbg.Events.SetImage:
			err := tbg.setImage(
				evt.Path,
				Option(evt.Alignment).UnwrapOr(DefaultAlignment),
				Option(evt.Opacity).UnwrapOr(DefaultOpacity),
				Option(evt.Stretch).UnwrapOr(DefaultStretch),
			)
			if err != nil {
				return err
			}
		}
	}
}

// Changes the background image to a randomly chosen image from images in dirs
// under "paths" in the tbg config file
func (tbg *TbgState) changeToRandomImage(
	alignment *string,
	opacity *float32,
	stretch *string,
) error {
	currentImage, currentAlignment, currentOpacity, currentStretch, err := tbg.randomImage()
	if err != nil {
		return err
	}
	currentAlignment = Option(alignment).UnwrapOr(currentAlignment)
	currentOpacity = Option(opacity).UnwrapOr(currentOpacity)
	currentStretch = Option(stretch).UnwrapOr(currentStretch)
	return tbg.setImage(currentImage, currentAlignment, currentOpacity, currentStretch)
}

// Sets the passed in image path with its properties as the current background
// image
func (tbg *TbgState) setImage(
	imagePath string,
	alignment string,
	opacity float32,
	stretch string,
) error {
	err := tbg.Settings.Write(
		imagePath,
		tbg.Config.ProfileOrDefault(),
		alignment,
		opacity,
		stretch,
	)
	if err != nil {
		return err
	}
	slog.Info("Changed image",
		"image", imagePath,
		"profile", tbg.Config.ProfileOrDefault(),
		"alignment", alignment,
		"opacity", opacity,
		"stretch", stretch,
	)
	return nil
}

// Selects a random image from dirs in "paths" field set in tbg config
func (tbg *TbgState) randomImage() (string, string, float32, string, error) {
	randomPath := tbg.Config.Paths[uint16(rand.IntN(len(tbg.Config.Paths)))]
	var err error
	tbg.Images, err = randomPath.Images()
	if err != nil {
		return "", "", 0.0, "", err
	}
	return tbg.Images[uint16(rand.IntN(len(tbg.Images)))],
		Option(tbg.OverrideAlignment).Or(randomPath.Alignment).UnwrapOr(DefaultAlignment),
		Option(tbg.OverrideOpacity).Or(randomPath.Opacity).UnwrapOr(DefaultOpacity),
		Option(tbg.OverrideStretch).Or(randomPath.Stretch).UnwrapOr(DefaultStretch),
		nil
}
